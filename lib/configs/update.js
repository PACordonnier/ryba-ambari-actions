// Generated by CoffeeScript 2.0.2
// # Ambari Configs update

// Updates ambari named config using the [REST API v2](https://github.com/apache/ambari/blob/trunk/ambari-server/docs/api/v1)

// * `password` (string)
//   Ambari Administrator password.
// * `url` (string)
//   Ambari External URL.
// * `username` (string)
//   Ambari Administrator username.
// * `cluster_name` (string)
//   Name of the cluster, required
// * `config_type` (string)
//   config of the name to modify example core-site, hdfs-site... required.
// * `properties` (object)
//   properties to add to the configuration, required.
// * `tag` (string)
//   tag of the updated config, will be computed if no provided to: 'version' + version
// * `current_tag` (string)
//   the current tag of the config_type, will read from ambari's server if not provided.
// * `description` (string)
//   a note describing what modifications user provides
// * `source` (string)
// a source file to read the properties from. can be used with properties options. For now
// only .xml file are supported
// * `merge` (boolean)
// Read properties for the current version (if exists) and merge properties. true by default.

// ## Exemple

// ```js
// configs.update({
//   "username": 'ambari_admin',
//   "password": 'ambari_secret',
//   "url": "http://ambari.server.com",
//   "config_type": 'hdfs-site',
//   "properties": { "dfs.nameservices": "mycluster"}
//   }
// }, function(err, status){
//   console.log( err ? err.message : "Properties UPDATED: " + status)
// })
// ```

// ## Source Code
var merge, path, utils;

module.exports = function(options, callback) {
  var differences, do_diff, do_end, do_update, err, error, get_current_version, hostname, opts, path, port;
  error = null;
  differences = false;
  if (options.debug == null) {
    options.debug = false;
  }
  if (options.merge == null) {
    options.merge = true;
  }
  do_end = function() {
    if (callback != null) {
      return callback(error, differences);
    }
    return new Promise(function(fullfil, reject) {
      if (error != null) {
        reject(error);
      }
      return fullfil(differences);
    });
  };
  try {
    if (!options.username) {
      throw Error('Required Options: username');
    }
    if (!options.password) {
      throw Error('Required Options: password');
    }
    if (!options.url) {
      throw Error('Required Options: url');
    }
    if (!options.cluster_name) {
      throw Error('Required Options: cluster_name');
    }
    if (!options.config_type) {
      throw Error('Required Options: config_type');
    }
    if (!(options.source || options.properties)) {
      throw Error('Required Options: source or properties');
    }
    if (options.source && options.properties) {
      throw Error('Source and properties can not be specified simultaneously');
    }
    [hostname, port] = options.url.split("://")[1].split(':');
    if (options.sslEnabled == null) {
      options.sslEnabled = options.url.split('://')[0] === 'https';
    }
    path = `/api/v1/clusters/${options.cluster_name}`;
    opts = {
      hostname: hostname,
      port: port,
      rejectUnauthorized: false,
      headers: utils.headers(options),
      sslEnabled: options.sslEnabled
    };
    opts['method'] = 'GET';
    // get current tag for actual config
    get_current_version = function() {
      opts.path = `${path}?fields=Clusters/desired_configs`;
      return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
        var desired_configs;
        try {
          if (err) {
            throw err;
          }
          response = JSON.parse(response);
          if (statusCode !== 200) {
            throw Error(response.message);
          }
          desired_configs = response['Clusters']['desired_configs'];
          if (options.stack_version == null) {
            options.stack_version = response['Clusters']['version'];
          }
          if (options.cluster_name == null) {
            options.cluster_name = response['Clusters']['cluster_name'];
          }
          if (options.debug) {
            // note each configuration has two files tag and version
            // the tag is a string while the version the id as an integer
            // this id will be used to get the latest version
            console.log(`stack_version ${options.stack_version}, cluster_name ${options.cluster_name}`);
          }
          if (desired_configs[options.config_type] != null) {
            options.current_version = desired_configs[options.config_type].version;
            options.current_tag = desired_configs[options.config_type].tag;
            if (options.config_version == null) {
              options.config_version = parseInt(options.current_version) + 1;
            }
            if (options.tag == null) {
              options.tag = `version${options.config_version}`;
            }
            return do_diff();
          }
          if (options.tag == null) {
            options.tag = 'version1';
          }
          options.config_version = 1;
          return do_update();
        } catch (error1) {
          err = error1;
          error = err;
          return do_end();
        }
      });
    };
    do_diff = function() {
      if (options.debug) {
        console.log("computing diff ambari.configs.update");
      }
      // do diff with the current config tag
      opts.path = `${path}/configurations?type=${options.config_type}&tag=${options.current_tag}`;
      opts['method'] = 'GET';
      return utils.doRequestWithOptions(opts, function(err, statusCode, response) {
        var current_configs, current_properties, prop, ref, value;
        try {
          if (err) {
            throw err;
          }
          response = JSON.parse(response);
          if (statusCode !== 200) {
            throw Error(response.message);
          }
          current_configs = response['items'].filter(function(item) {
            return item.version === options.current_version;
          });
          if (current_configs.length !== 1) {
            throw Error(`No config found for version ${options.current_version}`);
          }
          current_properties = current_configs[0].properties;
          if (options.merge) {
            options.properties = merge({}, current_properties, options.properties);
          }
          ref = options.properties;
          //return do_update()
          for (prop in ref) {
            value = ref[prop];
            if (`${current_properties[prop]}` !== `${value}`) {
              differences = differences || true;
              break;
            }
          }
          if (differences) {
            return do_update();
          } else {
            return do_end();
          }
        } catch (error1) {
          err = error1;
          error = err;
          return do_end();
        }
      });
    };
    do_update = function() {
      var err;
      try {
        if (options.debug) {
          console.log(`update ${options.config_type} with tag: ${options.tag} version:${options.config_version}`);
        }
        if (options.description == null) {
          options.description = `updated config ${options.config_type}`;
        }
        options.config_version = parseInt(options.current_version) + 1;
        if (options.tag == null) {
          options.tag = `version${options.config_version}`;
        }
        differences = true;
        if (opts.content == null) {
          opts.content = options.content != null ? options.content : options.content = JSON.stringify([
            {
              Clusters: {
                desired_config: [
                  {
                    type: options.config_type,
                    tag: options.tag,
                    properties: options.properties,
                    service_config_version_note: options.description
                  }
                ]
              }
            }
          ]);
        }
        // opts.headers['Content-Type'] = 'application/json'
        opts.method = 'PUT';
        opts.path = `${path}`;
        return utils.doRequestWithOptions(opts, (err, statusCode, response) => {
          error = err;
          try {
            if (response !== '') {
              response = JSON.parse(response);
              if (statusCode !== 200) {
                throw Error(response.message);
              }
            }
          } catch (error1) {
            err = error1;
            return error = err;
          } finally {
            do_end();
          }
        });
      } catch (error1) {
        err = error1;
        error = err;
        return do_end();
      }
    };
    return get_current_version();
  } catch (error1) {
    err = error1;
    error = err;
    return do_end();
  }
};

// ## Depencendies
utils = require('../utils');

path = require('path');

({merge} = require('nikita/lib/misc'));
